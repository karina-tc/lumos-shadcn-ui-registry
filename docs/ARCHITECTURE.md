# Lumos Design System — Architecture

## Overview

The Lumos design system is split across two repos that serve different audiences:

| Repo | Purpose | Audience |
|------|---------|----------|
| **lumos-shadcn-ui-registry** (this repo) | Source of truth for components, blocks, and tokens | Design system maintainers |
| **lumos-prototype** (consumer) | Ready-to-go Next.js app for building prototypes | Designers, PMs, anyone prototyping with Claude |

The registry publishes JSON artifacts that the prototype (and V0, Cursor, etc.) consume via the shadcn CLI.

## How the two repos connect

```
┌──────────────────────────────────────┐
│  lumos-shadcn-ui-registry            │
│                                      │
│  registry.json (source)              │
│       │                              │
│  npx shadcn build                    │
│       │                              │
│  public/r/*.json (built artifacts)   │
│       │                              │
│  Deployed to Vercel                  │
└───────┬──────────────────────────────┘
        │  HTTPS
        ▼
┌──────────────────────────────────────┐
│  lumos-prototype                     │
│                                      │
│  npx shadcn add <url> --overwrite    │
│       │                              │
│  Installs components + tokens        │
│  into local project                  │
└──────────────────────────────────────┘
```

The prototype ships with everything pre-installed. The `/sync-registry` skill pulls updates when the registry changes.

## Registry repo structure

```
src/
  components/           # Lumos components (brand-header, page-header, etc.)
  components/ui/        # shadcn primitives (button, card, table, etc.)
  layouts/              # Standalone layout wrappers (lumos-app-layout, etc.)
  hooks/                # Shared hooks (use-mobile)
  lib/                  # Utilities (cn, registry helpers, products data)
  app/
    layout.tsx          # Demo app root layout
    (registry)/         # Registry browser UI (list, detail, tokens pages)
    demo/[name]/        # Dynamic demo renderer
      index.tsx         # Maps registry item names → React components
      renderer.tsx      # Client-side theme sync
      blocks/           # Demo implementations for blocks
      components/       # Demo implementations for custom components
      ui/               # Demo implementations for UI primitives
  __tests__/            # Registry integrity tests (vitest)

public/
  r/                    # Built registry artifacts (gitignored, generated by build)
  fonts/                # Roobert woff2 files

registry.json           # Source manifest — all items defined here
components.json         # shadcn CLI configuration
vitest.config.ts        # Test configuration
```

## Registry item types

| Type | What it is | Example |
|------|-----------|---------|
| `registry:theme` | CSS custom properties + globals | `theme` |
| `registry:ui` | shadcn primitive component | `button`, `card`, `table` |
| `registry:component` | Lumos-branded component | `brand-header`, `lumos-badge` |
| `registry:block` | Full page or multi-file install | `lumos-apps-index`, `lumos-full-app` |

## Build pipeline

```bash
pnpm build
# 1. npx shadcn@latest build  →  reads registry.json, outputs public/r/*.json
# 2. next build                →  builds the demo/browser app
```

The `shadcn build` step is the critical one for consumers. It transforms each registry item into a standalone JSON file at `public/r/{name}.json` that contains the component source code, dependencies, and install targets.

## Token system

Lumos uses a three-layer token architecture:

```
Layer 1: Primitives (defined in globals.css)
  --lumos-neutral-50, --lumos-orange-600, --lumos-blue-500, etc.

Layer 2: Semantic aliases (mapped to shadcn conventions)
  --primary: var(--lumos-orange-600)
  --background: var(--lumos-neutral-0)
  --foreground: var(--lumos-neutral-900)
  --destructive: var(--lumos-red-600)

Layer 3: Tailwind classes (what you use in code)
  bg-primary, text-foreground, border-border, etc.
```

Consumers never touch CSS variables directly — they use Tailwind semantic classes.

## The full-app block

The `lumos-full-app` registry block is the key artifact for prototyping. It installs:

- **1 root layout** (`app/layout.tsx`) — wraps everything in FullAppShell
- **14 content-only pages** — one for each route (Apps, Identities, Accounts, etc.)

Plus 8 component dependencies resolved automatically:
- theme, full-app-layout, page-header, page-tabs
- albus-chat-input, albus-history-panel, albus-symbol, lumos-symbol

### FullAppShell architecture

```
FullAppShell (client component)
  ├── BrandHeader
  │     ├── Logo + sidenav toggle
  │     ├── Breadcrumb (title from pathname)
  │     ├── Notifications
  │     └── User menu
  ├── Container (flex row)
  │     ├── BrandSidebar (208px or 0)
  │     │     └── Products / Inventory / Workspace sections
  │     └── Content area (flex-1)
  │           └── {children} ← page content
  └── Portals (menus, suggestions)
```

Route matching uses `usePathname()`:
1. Exact match first (`/settings` → "Settings")
2. Longest prefix match for nested routes (`/albus/chat` → "Ask Albus")

### Page patterns

Every page follows one of five patterns:

| Pattern | Example | Structure |
|---------|---------|-----------|
| Table index | Apps, Identities, Tasks | PageHeader + search/filter bar + table |
| Dashboard | Analytics | PageHeader + stat cards + charts + table |
| Card grid | Integrations | PageHeader + sectioned card grids |
| Form | Settings | PageHeader + vertical nav + form sections |
| Chat | Albus | Centered AlbusChatInput + suggestions |

## BrandSidebar navigation

The sidebar supports two rendering modes for nav items:

```tsx
// Button mode (default) — for items with subItems or no href
{ label: "Employee Lifecycle", subItems: [...] }

// Link mode — renders <a> tag when href is present
{ label: "Apps", href: "/" }

// SubItem objects can also be links
{ label: "Onboarding", href: "/onboarding" }
```

This is backward-compatible: existing `string[]` subItems still work.

## Demo system

Every registry item has a corresponding demo at `/demo/{name}`. The demo system:

1. `generateStaticParams()` pre-builds routes for all items
2. `index.tsx` maps item names to React component trees
3. `renderer.tsx` handles client-side theme sync via localStorage
4. Demo components live in `blocks/`, `components/`, or `ui/` subdirectories

## Testing

```bash
pnpm test        # Run once
pnpm test:watch  # Watch mode
```

Five structural integrity tests validate:
1. Every item has a unique name
2. Every file path in registry.json exists on disk
3. No duplicate file targets within a single item
4. Every URL-based registryDependency references a valid item
5. The lumos-full-app block has the expected page targets

## Adding to the registry

### New component
1. Create `src/components/{name}.tsx`
2. Create demo at `src/app/demo/[name]/components/{name}.tsx`
3. Register demo in `src/app/demo/[name]/index.tsx`
4. Add entry to `registry.json`
5. Run `pnpm build` to verify

### New block (page)
1. Create standalone page in `src/app/demo/[name]/blocks/{name}.tsx`
2. Create content-only version in `blocks/full-app/{name}-page.tsx`
3. Register demo in `blocks/lumos-demos.tsx`
4. Add entry to `registry.json`
5. Add route to `full-app-layout.tsx` (routes + navSections)
6. Run `pnpm test && pnpm build` to verify

Or use the `/add-component` and `/add-block` skills in Claude Code.

## Naming conventions

| Kind | Pattern | Example |
|------|---------|---------|
| Lumos component | `lumos-{name}` | `lumos-badge` |
| Brand component | `brand-{name}` | `brand-header` |
| Albus component | `albus-{name}` | `albus-chat-input` |
| Page block | `lumos-{page}-index` | `lumos-apps-index` |
| Layout component | `{name}-layout` | `full-app-layout` |
| Full-app page file | `{page}-page.tsx` | `apps-page.tsx` |
